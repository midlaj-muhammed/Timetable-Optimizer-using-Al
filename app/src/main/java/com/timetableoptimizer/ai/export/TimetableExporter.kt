package com.timetableoptimizer.ai.export

import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Paint
import android.graphics.pdf.PdfDocument
import android.net.Uri
import android.provider.CalendarContract
import androidx.core.content.FileProvider
import com.timetableoptimizer.ai.data.entities.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.time.LocalDateTime
import java.time.ZoneId
import java.time.format.DateTimeFormatter
import java.util.*

class TimetableExporter(private val context: Context) {
    
    data class ExportResult(
        val success: Boolean,
        val filePath: String? = null,
        val uri: Uri? = null,
        val message: String
    )
    
    suspend fun exportToPdf(
        timetable: Timetable,
        entries: List<TimetableEntry>,
        timeSlots: List<TimeSlot>,
        subjects: List<Subject>
    ): ExportResult = withContext(Dispatchers.IO) {
        try {
            val pdfDocument = PdfDocument()
            val pageInfo = PdfDocument.PageInfo.Builder(595, 842, 1).create() // A4 size
            val page = pdfDocument.startPage(pageInfo)
            val canvas = page.canvas
            
            drawTimetableToPdf(canvas, timetable, entries, timeSlots, subjects)
            
            pdfDocument.finishPage(page)
            
            val fileName = "timetable_${timetable.name.replace(" ", "_")}_${System.currentTimeMillis()}.pdf"
            val file = File(context.getExternalFilesDir(null), fileName)
            
            FileOutputStream(file).use { outputStream ->
                pdfDocument.writeTo(outputStream)
            }
            
            pdfDocument.close()
            
            val uri = FileProvider.getUriForFile(
                context,
                "${context.packageName}.fileprovider",
                file
            )
            
            ExportResult(
                success = true,
                filePath = file.absolutePath,
                uri = uri,
                message = "PDF exported successfully"
            )
        } catch (e: Exception) {
            ExportResult(
                success = false,
                message = "Failed to export PDF: ${e.message}"
            )
        }
    }
    
    suspend fun exportToImage(
        timetable: Timetable,
        entries: List<TimetableEntry>,
        timeSlots: List<TimeSlot>,
        subjects: List<Subject>
    ): ExportResult = withContext(Dispatchers.IO) {
        try {
            val bitmap = Bitmap.createBitmap(1200, 800, Bitmap.Config.ARGB_8888)
            val canvas = Canvas(bitmap)
            canvas.drawColor(Color.WHITE)
            
            drawTimetableToCanvas(canvas, timetable, entries, timeSlots, subjects)
            
            val fileName = "timetable_${timetable.name.replace(" ", "_")}_${System.currentTimeMillis()}.png"
            val file = File(context.getExternalFilesDir(null), fileName)
            
            FileOutputStream(file).use { outputStream ->
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, outputStream)
            }
            
            val uri = FileProvider.getUriForFile(
                context,
                "${context.packageName}.fileprovider",
                file
            )
            
            ExportResult(
                success = true,
                filePath = file.absolutePath,
                uri = uri,
                message = "Image exported successfully"
            )
        } catch (e: Exception) {
            ExportResult(
                success = false,
                message = "Failed to export image: ${e.message}"
            )
        }
    }
    
    fun exportToCalendar(
        timetable: Timetable,
        entries: List<TimetableEntry>,
        timeSlots: List<TimeSlot>,
        subjects: List<Subject>
    ): Intent {
        val calendarIntent = Intent(Intent.ACTION_INSERT).apply {
            data = CalendarContract.Events.CONTENT_URI
            putExtra(CalendarContract.Events.TITLE, timetable.name)
            putExtra(CalendarContract.Events.DESCRIPTION, timetable.description ?: "Generated by Timetable Optimizer AI")
            
            // For simplicity, we'll create a single calendar event
            // In a real implementation, you might want to create multiple events
            val firstEntry = entries.firstOrNull()
            val firstTimeSlot = firstEntry?.let { entry ->
                timeSlots.find { it.id == entry.timeSlotId }
            }
            
            if (firstTimeSlot != null) {
                val startTime = LocalDateTime.of(
                    java.time.LocalDate.now().with(firstTimeSlot.dayOfWeek),
                    firstTimeSlot.startTime
                )
                val endTime = LocalDateTime.of(
                    java.time.LocalDate.now().with(firstTimeSlot.dayOfWeek),
                    firstTimeSlot.endTime
                )
                
                putExtra(CalendarContract.EXTRA_EVENT_BEGIN_TIME, 
                    startTime.atZone(ZoneId.systemDefault()).toEpochSecond() * 1000)
                putExtra(CalendarContract.EXTRA_EVENT_END_TIME,
                    endTime.atZone(ZoneId.systemDefault()).toEpochSecond() * 1000)
            }
        }
        
        return calendarIntent
    }
    
    fun createShareIntent(uri: Uri, mimeType: String): Intent {
        return Intent(Intent.ACTION_SEND).apply {
            type = mimeType
            putExtra(Intent.EXTRA_STREAM, uri)
            putExtra(Intent.EXTRA_TEXT, "Check out my timetable created with Timetable Optimizer AI!")
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
    }
    
    private fun drawTimetableToPdf(
        canvas: Canvas,
        timetable: Timetable,
        entries: List<TimetableEntry>,
        timeSlots: List<TimeSlot>,
        subjects: List<Subject>
    ) {
        val paint = Paint().apply {
            isAntiAlias = true
            textSize = 12f
            color = Color.BLACK
        }
        
        val titlePaint = Paint().apply {
            isAntiAlias = true
            textSize = 18f
            color = Color.BLACK
            isFakeBoldText = true
        }
        
        // Draw title
        canvas.drawText(timetable.name, 50f, 50f, titlePaint)
        canvas.drawText("Generated on ${DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm").format(LocalDateTime.now())}", 
            50f, 80f, paint)
        
        // Draw timetable grid
        val startY = 120f
        val cellWidth = 80f
        val cellHeight = 40f
        
        val days = listOf("Time", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
        
        // Draw headers
        days.forEachIndexed { index, day ->
            canvas.drawText(day, 50f + index * cellWidth, startY, paint)
        }
        
        // Draw time slots and entries
        val uniqueTimeSlots = timeSlots.distinctBy { "${it.startTime}-${it.endTime}" }.sortedBy { it.startTime }
        val entriesByTimeSlot = entries.associateBy { it.timeSlotId }
        val subjectsById = subjects.associateBy { it.id }
        
        uniqueTimeSlots.forEachIndexed { rowIndex, timeSlot ->
            val y = startY + (rowIndex + 1) * cellHeight
            
            // Draw time
            canvas.drawText("${timeSlot.startTime}-${timeSlot.endTime}", 50f, y, paint)
            
            // Draw entries for each day
            DayOfWeek.values().forEachIndexed { dayIndex, day ->
                val dayTimeSlot = timeSlots.find { 
                    it.dayOfWeek == day && it.startTime == timeSlot.startTime && it.endTime == timeSlot.endTime 
                }
                val entry = dayTimeSlot?.let { entriesByTimeSlot[it.id] }
                val subject = entry?.let { subjectsById[it.subjectId] }
                
                val x = 50f + (dayIndex + 1) * cellWidth
                
                if (subject != null) {
                    canvas.drawText(subject.code, x, y, paint)
                }
            }
        }
    }
    
    private fun drawTimetableToCanvas(
        canvas: Canvas,
        timetable: Timetable,
        entries: List<TimetableEntry>,
        timeSlots: List<TimeSlot>,
        subjects: List<Subject>
    ) {
        val paint = Paint().apply {
            isAntiAlias = true
            textSize = 24f
            color = Color.BLACK
        }
        
        val titlePaint = Paint().apply {
            isAntiAlias = true
            textSize = 36f
            color = Color.BLACK
            isFakeBoldText = true
        }
        
        // Draw title
        canvas.drawText(timetable.name, 50f, 80f, titlePaint)
        
        // Draw simplified timetable representation
        val startY = 150f
        val cellWidth = 150f
        val cellHeight = 60f
        
        val days = listOf("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
        
        // Draw day headers
        days.forEachIndexed { index, day ->
            canvas.drawText(day, 50f + index * cellWidth, startY, paint)
        }
        
        // Draw some sample entries (simplified for image export)
        val sampleEntries = entries.take(7) // Show first 7 entries
        sampleEntries.forEachIndexed { index, entry ->
            val subject = subjects.find { it.id == entry.subjectId }
            if (subject != null) {
                val x = 50f + (index % 7) * cellWidth
                val y = startY + 80f
                canvas.drawText(subject.code, x, y, paint)
            }
        }
    }
}
